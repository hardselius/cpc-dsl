\chapter{Language}\label{chap:language}
This chapter describes the domain-specific language
Codspeech\footnote{COpernicus Domain-SPEcific langagE, CHalmers}, as
well as the rationale behind the design.

For a complete description of the grammar in Backus-Naur Form (BNF),
see \autoref{sec:bnf}. The implementation details will be described
further in \autoref{chap:implementation}.


\section{Design}
Designing the DSL was a process which continued through the entire
project. As there are no text based solution to similar problems, the
DSL had no real starting base. The initial inspiration came from the
reasearch on programming praradigms and graphical implementations
related to network based programming.

Inspiration from well known programming languages was included for the
DSL to be simple and intuitive to the common user. Both functional and
imperative languages were considered when developing the design.

The most important steps in this process was a continuing discussion
with the developers of Copernicus. It was important to have a DSL
which they were satisfied with, but also to get input on what design
choices to make. The developers perspective was important for the DSL
to reflect realistic scenarios and to get a better collective view of
the different solutions. At each meeting the developers was presented
with a draft of the latest version of the DSL.

\section{General style and features}

\highlight{lower case}

\highlight{can assign primitives to inputs}

\highlight{define before use, developers choice}

\highlight{input does not need to get values, since components only
  evaluate once it has all non-optional inputs}

\section{Modules}
Modules have no real function in the current implementation of the
language. A module is basically a code file. Importing a file is
importing a module. This is how to import the file
``path/to/file.cod'' from subdirectories of the current files path:

\begin{verbatim}
import path.to.file
\end{verbatim}

All code from the imported module is simply added where the import
statement is located in the code. This way the code from the imported
file will be used as it would have been written in the current
file. This system is not designed or developed to have modules and
packages as wrappers for code, but rather to sort code in different
files. 

Currently it is only possible to import files from
subdirectories. There are no way to import from other paths or any
form of a standard library. The discussion of a more advanced and
useful import system revealed that the developers had some different
suggestions but had not decided how such a system should work with
client server setup in Copernicus.

\subsection{Future Work}

A real functional import system is needed for the language to be
realistically added to Copernicus. The developers will need to define
how Copernicus should handle imports, since they have not decided what
would be the most practicle and useful way to do this.

Importing standard libraries needs to be defined before the
client/server issues in Copernicus can be addressed. This may be an
easy problem but it is still vital for continuing the
implementation. Once this is done the developers needs to decide where
the code should be parsed and typechecked. The client can do all this
work and send it to the server but as the rest of the client is very
light and does not do much work, other than communicate with the
server, a prefered solution is to have the server do all the work. The
client can still add imports and build one code file for the server or
send all the used code files. As there are a difference between
importing from the standard library and importing user written project
specific files, it needs to be decided how the client and server will
work together to build the project. If the server should do most of
the work it needs to have all the libraries.

Assuming the server would get all user written files, building
projects, and doing all the work, a question is what the client should
be able to do. Users may for example be able to typecheck their
projects before sending them to a server, as it would make development
easier. If so, the client needs to have access to all the labraries
the server does.

There were a suggestion for a repository containing all libraries,
where code can be added and fetched when not available locally. Users
could easily add their own implementations. Such a repository needs to
handle executables aswell, since servers needs be able to supply them
to the workers.

\section{Typing}
In the language all connections between executables are typed. Their
types are set when inputs and outputs are defined. Atoms and even
networks have types according to their external inputs and outputs.

The typechecker does not typecheck executables. Instead the system
relies on the correct defenition when wrapping them in the language.

\subsection{Primitive Types}
The first primitive is integers, which are represented by
\verb#int#. Integers cannot be assigned floating points (implicitly
turn floating point to integer) but has to be assigned
integers. Floating points are represented as \verb#float#, and as
integers floating points cannot be assigned anything other than
floating points. This means that \verb#1.0# is not the same as
\verb#1# in the language and will cause a type error if assigned to a
connection with the wrong type.

Strings are represented by \verb#string#. Strings are written
\verb#"string"# when assigned to connections. The last primitive type
is files, which are described as \verb#file#. Files are paths written
like strings, but are not checked that it is a path to a file.

\subsection{Compound Types}\label{sec:compound}
There are two compound types in the language. The first one are
arrays, which are ordered lists of a certain type. An integer array is
written like \verb#int[]#, where each pair of brackets represent one
dimension. It is possible to have any number of dimensions of
arrays. Accessing the fourth element of a variable \verb#x# which is
typed as the example integer array, is written \verb#x[4]#. The
resulting type of accessing elements is the same type with one less
dimension. In the example that would be an integer (\verb#int#).

The second compound type is records. They are orderd sets of elements
which are assigned names. This make it possible to access elements in
a record by both its index and name. Accessing the fourth variable
\verb#e# of a record \verb#x# using its name would be written as
\verb#x.e#, and to access \verb#x# by its index would be written as
\verb#x(4)#. The elements can have any kind of type and does not have
to have the same type as the other elements in the record. A new type
has to be defined to represent a record.

\subsection{New Types}
Defining new types are the way records are described in the
language. A new type needs a name and which types of elements it
contains. Each element needs a type and a unique name in the
record. New types can only be defined outside networks and atoms.

The syntax for defining a new type begins with the keyword
\verb#type#. Consider a record called \verb#setting# containing a file
called \verb#f# and a string called \verb#name#. The following code
represents this record \verb#setting#.

\begin{verbatim}
type setting
    ( file  : f
    , float : name )
\end{verbatim}

The file has in this case index zero and the file has index one. They
can be access with both name and index as described above.

\subsection{Atom \& Network Type}\label{sec:atomnet}
As atoms and networks are able to have any number of inputs and
outputs their types are a special case of a record. Such records
contain three elements: inputs, outputs, meta parameters. The inputs
and outputs are records aswell, in which every input and output
parameter are elements. The meta parameter is a record which should
contain types and is more explained in the section \autoref{sec:meta}.

An atom or network with an array of type \verb#setting# called
\verb#settings# and an integer called \verb#length# as inputs and a
file called \verb#output# as outputs, is described by the following
syntax.

\begin{verbatim}
in ( setting[] settings
   , int       length  )
out ( file output )
\end{verbatim}

The full header syntax for networks and atoms is described in sections
\autoref{sec:net} and \autoref{sec:atom}.

Since both the type of \verb#in# and the type of functions are
records, there are numerous ways of refering to an input
parameter. Refering to the a parameter \verb#length# when a function
of the same type as the above has been instantiated as \verb#func# may
look like \verb#func.in.length# or \verb#func(0)(1)# which both are
the same thing.

\subsection{Meta Types}\label{sec:meta}
Atoms and networks can take types as inputs, called meta types, to be
able to define generic components in networks. The parameters are
defined with a variable name and a type group. There are currently
three different type groups: \verb#func#, \verb#list#, and
\verb#type#. The group is a constraint on the type parameter which
accepts only certain types. The group \verb#type# means the parameter
only accepts primitive types, \verb#list# accepts compound type
(records and arrays), and \verb#func# accepts record types which at
least have an element \verb#in# and an element \verb#out#. This way
one can define new types which can be used to describe atom and
network types.

The type parameters are defined and as the following example:

\begin{verbatim}
<func f, list l, type t>
\end{verbatim}

\begin{verbatim}
in ( f.in i
   , l*   inputs
out ( t[] outputs )
\end{verbatim}

\verb#i# will be of a record type since \verb#in# is a record. The
symbol \verb#*# removes one dimension from the array \verb#l#. The
output \verb#outputs# will be a one dimensional array where the type
is given by the parameter \verb#t#.

\subsection{Type System}
%what is checked...

%parameters to atoms and networks are checked

%metatypes are checked

\subsection{Future Work}
\highlight{?}


\section{Variables}
Variables refer to an instantiated atom or a network. They are
instantiated inside networks, where they can be connected to other
variables or external inputs and outputs. How to instantiate a
variable is described in section \autoref{sec:stmt}.

Variables contains letters, numbers, and underscores, but they have to
start with a lower case letter.

\section{Atoms}\label{sec:atom}
An atom is a wrapper for executable code, python scripts and
functions. In the language atoms are components just like networks and
the information of what to execute and how is hidden inside the
lanugage for a more intuitive way of building project
networks. Executables should be wrapped and added to an appropriate
library so users do not have to conern themselves with external
(outside the language) project design.

An atom has a header and an option part. The header contains the name
of the atom, the type parameter defenition, the type signature of the
outputs and inputs, and what type of executable the atom uses. There
are three different types of executables in the current version:
\verb#python#, \verb#python-extended#, and
\verb#external#. \verb#python# means that the atom calls built-in
functions of python, \verb#python-extended# means the atom calls
python scripts, and \verb#external# calls binary executables.

The following code is the header for an atom \verb#someatom# which
calls a binary executable and has the type defenition used in previous
sections (note that in this case the type parameters are not used but
are there to give a full description of a header).

\begin{verbatim}
atom external someatom <func f, list l, type t>
  in  ( setting[] settings
      , int       length  )
  out ( file output )
\end{verbatim}

The option part is a list of options and values. The options are the
information on what and how to execute for Copernicus. The values are
relative to Copernicus and are not a part of the language, which is
why users should not have to write atoms themselves but import and use
pre-defined atoms.

The following code is the defenition of an atom \verb#add# which uses
a built-in python function to add two floating points together.

\begin{verbatim}
atom python add
  in  ( float a
      , float b )
  out ( float o )
  options ( fuction : builtin.float.add
          , import  : builtin.float )
\end{verbatim}

\section{Networks}\label{sec:net}

A network is a description of what to instantiate and how the
components and external input/outputs are connected inside the
network. Networks can be components the same way as atoms, which makes
them subnetworks when instantiated in other networks.

The header of a network differs from atoms headers on two points. The
key word \verb#atom# is replaced with \verb#network# and a network
does not have an executable type. Writing a network \verb#somenet#
with the same parameters and type signature as \verb#someatom# looks
like this:

\begin{verbatim}
network somenet <func f, list l, type t>
  in  ( setting[] settings
      , int       length  )
  out ( file output )
\end{verbatim}

The second part of a network is its network body which is a list of
statements seperated by new lines. These statements are the
description of the network, and they are described in detail in the
next section.

\section{Statements} \label{sec:stmt}
There are three types of statements: assignment, connections, and a
controller statement. With these statements a network can be described
inside a network body. It is not possible to build networks outside a
network defenition.

Assignment statements are instantiations of either networks or atoms
which are assigned to variables. An assignement needs an expression
with information of what atom/network and with which arguments, meta
types and inputs, is instantiated. All the type arguments needs to be
given when instantiated, but as it is not mandatory to connect
something to an input the input arguments can be left empty. Arguments
are connected to their respective input in the order they are defined
in the atom/network.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Type parameters are type references as meta types
\autoref{sec:meta}. They are listed between the symbols \verb#<# and
\verb#>#.

parameters references as in \autoref{sec:compound} and
\autoref{sec:atomnet}. They are listed between the symbols \verb#(#
and \verb#)#.

constants

nestled components

syntax

\begin{verbatim}
var = add (1.1 in.fp)
\end{verbatim}

\begin{verbatim}
var = somenet <add,add.in,float> ()
\end{verbatim}


connection
reference = reference
reference = constant

\begin{verbatim}
out.o <- var.out.o
\end{verbatim}

\begin{verbatim}
out.o <- 4.3
\end{verbatim}


controller statement which is explained in the next section

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Controllers}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
When defining an atom/network as a controller, it is given permission
to instatiate atoms, networks, and add connections within the current
network.

\begin{verbatim}
var = somecontroller (in)
controller(var)
\end{verbatim}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\section{Documentation \& Comments}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{verbatim}
atom python add   '''Add two floating point numbers: q=a+b'''
  in  ( float a
      , float b )
  out ( float o   '''a+b'''
      )
  options ( fuction : builtin.float.add
          , import  : builtin.float )
\end{verbatim}

The language has both line and block comments. A line comment start
with the symbol \verb#\## and anything after it will be skipped by the
parser. Block comments starts with \verb#/\## and ends with
\verb#\#/#. Anything within the block comment will be skipped by the
parser.

\begin{verbatim}
# This is a comment line

/#
This is a comment block


This is still in the comment block
/#
\end{verbatim}

The \verb#var# needs to be instantiated.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
