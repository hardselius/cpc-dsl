\chapter{Language}\label{chap:language}
This chapter describes the domain-specific language
Codspeech\footnote{COpernicus Domain-SPEcific langagE, CHalmers}, as
well as the rationale behind the design.

For a complete description of the grammar in Backus-Naur Form (BNF),
see \autoref{sec:bnf}. The implementation details will be described
further in \autoref{chap:implementation}.


\section{Design}
Designing the DSL was a process which continued through the entire
project. As there are no text based solution to similar problems, the
DSL had no real starting base. The initial inspiration came from the
reasearch on programming praradigms and graphical implementations
related to network based programming.

Inspiration from well known programming languages was included for the
DSL to be simple and intuitive to the common user. Both functional and
imperative languages were considered when developing the design.

The most important steps in this process was a continuing discussion
with the developers of Copernicus. It was important to have a DSL
which they were satisfied with, but also to get input on what design
choices to make. The developers perspective was important for the DSL
to reflect realistic scenarios and to get a better collective view of
the different solutions. At each meeting the developers was presented
with a draft of the latest version of the DSL.

\section{General style and features}

\highlight{lower case}

\highlight{can assign primitives to inputs}

\highlight{define before use, developers choice}

\section{Modules}
Modules have no real function in the current implementation of the
language. A module is basically a code file. Importing a file is
importing a module. This is how to import the file
``path/to/file.cod'' from subdirectories of the current files path:

\begin{verbatim}
import path.to.file
\end{verbatim}

All code from the imported module is simply added where the import
statement is located in the code. This way the code from the imported
file will be used as it would have been written in the current
file. This system is not designed or developed to have modules and
packages as wrappers for code, but rather to sort code in different
files. 

Currently it is only possible to import files from
subdirectories. There are no way to import from other paths or any
form of a standard library. The discussion of a more advanced and
useful import system revealed that the developers had some different
suggestions but had not decided how such a system should work with
client server setup in Copernicus.

\subsection{Future Work}

A real functional import system is needed for the language to be
realistically added to Copernicus. The developers will need to define
how Copernicus should handle imports, since they have not decided what
would be the most practicle and useful way to do this.

Importing standard libraries needs to be defined before the
client/server issues in Copernicus can be addressed. This may be an
easy problem but it is still vital for continuing the
implementation. Once this is done the developers needs to decide where
the code should be parsed and typechecked. The client can do all this
work and send it to the server but as the rest of the client is very
light and does not do much work, other than communicate with the
server, a prefered solution is to have the server do all the work. The
client can still add imports and build one code file for the server or
send all the used code files. As there are a difference between
importing from the standard library and importing user written project
specific files, it needs to be decided how the client and server will
work together to build the project. If the server should do most of
the work it needs to have all the libraries.

Assuming the server would get all user written files, building
projects, and doing all the work, a question is what the client should
be able to do. Users may for example be able to typecheck their
projects before sending them to a server, as it would make development
easier. If so, the client needs to have access to all the labraries
the server does.

There were a suggestion for a repository containing all libraries,
where code can be added and fetched when not available locally. Users
could easily add their own implementations. Such a repository needs to
handle executables aswell, since servers needs be able to supply them
to the workers.

\section{Typing}
In the language all connections between executables are typed. Their
types are set when inputs and outputs are defined. Atoms and even
networks have types according to their external inputs and outputs.

The typechecker does not typecheck executables. Instead the system
relies on the correct defenition when wrapping them in the language.

\subsection{Primitive Types}
The first primitive is integers, which are represented by
\verb#int#. Integers cannot be assigned floating points (implicitly
turn floating point to integer) but has to be assigned
integers. Floating points are represented as \verb#float#, and as
integers floating points cannot be assigned anything other than
floating points. This means that \verb#1.0# is not the same as
\verb#1# in the language and will cause a type error if assigned to a
connection with the wrong type.

Strings are represented by \verb#string#. Strings are written
\verb#"string"# when assigned to connections. The last primitive type
is files, which are described as \verb#file#. Files are paths written
like strings, but are not checked that it is a path to a file.

\subsection{Compound Types}
There are two compound types in the language. The first one are
arrays, which are ordered lists of a certain type. An integer array is
written like \verb#int[]#, where each pair of brackets represent one
dimension. It is possible to have any number of dimensions of
arrays. Accessing the fourth element of a variable \verb#x# which is
typed as the example integer array, is written \verb#x[4]#. The
resulting type of accessing elements is the same type with one less
dimension. In the example that would be an integer (\verb#int#).

The second compound type is records. They are orderd sets of elements
which are assigned names. This make it possible to access elements in
a record by both its index and name. Accessing the fourth variable
\verb#e# of a record \verb#x# using its name would be written as
\verb#x.e#, and to access \verb#x# by its index would be written as
\verb#x(4)#. The elements can have any kind of type and does not have
to have the same type as the other elements in the record. A new type
has to be defined to represent a record.

\subsection{New Types}
Defining new types are the way records are described in the
language. A new type needs a name and which types of elements it
contains. Each element needs a type and a unique name in the
record. New types can only be defined outside networks and atoms.

The syntax for defining a new type begins with the keyword
\verb#type#. Consider a record called \verb#setting# containing a file
calld \verb#f# and a float array called \verb#a#. The following code
represents this record \verb#setting#.

\begin{verbatim}
type setting
    ( file    : f
    , float[] : a )
\end{verbatim}

The file has in this case index zero and the float array has index
one. They can be access with both name and index as described above.

\subsection{Atom \& Network Type}
As atoms and networks are able to have any number of inputs and
outputs their types are records in the lanugage. Such records contain
three elements: inputs, outputs, meta parameters. The inputs and
outputs are records aswell, in which every input and output parameter
are elements.

The meta parameters are explained in the next section.

parameters
meta parameter

building function type header. full function syntax in
\autoref{sec:net} and \autoref{sec:atom}

\begin{verbatim}
in  ( setting[] settings
    , float     input  )
out ( float     output )
\end{verbatim}

referencing a function
referencing an input or output

\subsection{Meta Types}
func, list, type

function names, new types,

\subsection{Type System}
what is checked...

\subsection{Future Work}
\highlight{?}

\section{Variables}
variable name formats

references: identifier variable, element by name, in out, index record
and array

\section{Atoms}\label{sec:atom}
header

arguments

options

\section{Networks}\label{sec:net}
header and arguments

body

\section{Statements}
asignment

connection

asigning constant

controller statement which is explained in the next section

\section{Controllers}
When defining an atom/network as a controller, it is given permission
to instatiate atoms, networks, and add connections within the current
network.

\begin{verbatim}
controller(var)
\end{verbatim}

The \verb#var# needs to be instantiated.
