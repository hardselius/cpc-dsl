\chapter{Implementation}\label{chap:implementation}


%\section{Implementation}
%The implementation stage started when the first design prototype was
%done. This stage was developed parallel to the design, as both parts
%influenced eachother.
%
%The first step was to write a parser for building abstract syntax
%trees. The objective was to write a BNF grammar which represented our
%design. The grammar contains definitions of statements, expressions,
%types, etc.
%
%A type checker was the next step to be implemented. A type checker can
%provide the user with more expressive error reporting, and will also
%facilitate the learning experience.
%
%The last step was the XML generation. As this step is the one
%connecting the project to Copernicus, it required a more detailed
%understanding of how the system described and used computational
%projects.

\section{Tools}

\subsection{Python}
The implementation language used for building Rheos was
python. However, python was not the first language considered. Other
languages considered were \emph{C, C++, C\#, F\#, Haskell} and
\emph{Java}. However, C\# and F\# was never really an option, since
both implementation, compilation and execution of code were tied to
Unix environments. The reason behind the consideration of the other
languages was that they are all supported by the \emph{BNF Converter}
(BNFC) \citep{bnfc:online}. BNFC is a compiler construction for
generating a compiler front-end from a \emph{Labeled BNF
  grammar}. Given this grammar, the tool produces
\begin{inparaenum}[(1)]
\item an abstract syntax implementation;
\item a case skeleton for the abstract syntax in the same language;
\item a lexer generator file;
\item a parser generator file;
\item a pretty-printer module;
\item a \LaTeX~file containing a specification of the language
\end{inparaenum} \citep{bnfc:online}.
While a compiler generator certainly would have made the
implementation a lot easier, the Copernicus system is written in
python, and python does not exist as a target for the BNF Converter.

Copernicus is designed to run on Unix machines with as few
dependencies as possible, which makes Java an unsuitable candidate --
there are possible difficulties of installing a Java runtime
environment on supercomputers.

Doing the implementation in the C language could have been a possible
solution, since it integrates well with python. Most Unix system does
indeed ship with \emph{gcc} or the \emph{GNU Compiler
  Collection}. However, some older Unix distributions will not have
gcc pre-installed, and others like recent versions of \emph{Solaris}
and \emph{OpenSolaris} will have gcc under a different location.

Haskell was ruled out due to the simple fact that it is not as
mainstream as the other languages. While Haskell is a very powerful
language for writing compilers, maintenance of the code base might
prove difficult for inexperienced users.

Virtually every Unix system ships with a python interpreter, and it is
natural to write python extensions to a system already written in
Python. Python is easy to learn and the code is easy to extend and
maintain. In spite of python not being a classical meta-programming
language, it became the implementation language of choice.


\subsection{PLY (Python Lex-Yacc)}\label{sec:ply}
\input{Chapters/SectionsImplementation/ply}


\section{Implementation details}
This section will describe the various implementation steps taken
during the construction of Rheos.

\subsection{Abstract Syntax Tree}\label{sec:ast}
\input{Chapters/SectionsImplementation/ast}


\subsection{Type-checker}\label{sec:typechecker}
\input{Chapters/SectionsImplementation/typechecker}


\subsection{XML generation}\label{sec:xml}
There is an implemented XML generator for an earlier version of the
implementation. Due to bigger changes other aspects were prioritized
and XML generation was left for the developers of Copernicus to
update. Since the language needs definitions before they can be used
the XML generation is an iteration through these definitions. The only
non-straight forward part to implement is the instantiations of
atoms/networks as inputs in an assignment statement. The earlier
version of the XML generator replaced such input expressions with an
assignment statement and then connected inputs and outputs to
represent the same thing.

The XML generator is a visitor as the type checker. Visiting the
different nodes in an abstract syntax tree prints the corresponding
XML code and visit its children to generate the entire definition with
indentations.

\subsection{Emacs mode}\label{sec:emacs}
The Emacs mode only contains syntax highlighting. The mode was created
to get a more realistic view of the example code that were used during
designing the DSL and testing the implementation. The syntax
highlighting adds some understanding of what the code actually
represents which made it easier to add and change specific parts of
the DSL.

\section{Future work}

\subsection{Lexer and Parser}
As described in~\myref{section}{sec:transpose}, there is a need for a
\texttt{transpose} primitive. This would have to be specified as a
special keyword in the lexer and also be addressed separately in the
parser.


\subsection{Type-checker}
What remains to be done and future work implementation-wise has a lot
to do with the type-checker. Since it was decided to add polymorphic
stage in the project, the type-checker had to be completely
parametrized typing to allow for generic components at a very late
re-written. This change proved to be very time-consuming.

The environment was re-written at the same time to make it more
powerful and intuitive to work with. Before the current
implementation, the environment consisted of a lot of different
records and lists, and did not perform well on look-ups.
