\chapter{Method}

\section{Research}

\subsection{Programming Paradigms}
We researched programming paradigms and programming languages similar
to what we wanted to build.

\subsubsection{Dataflow Programming}

\subsubsection{Flowbased Programming}

\subsubsection{Reactive Programming}
Oriented around data flows and the propagation of change. THe
underlying execution model will automatically propagate changes
through the data flow.


\section{Design}
from research -> inspiration from programming paradigms and graphical implementations

inspiration from programming languages, functional...imperative

drafts

discussion


\section{Implementation}
intro?...

\subsection{Language}
The candidates for implementation language were: C, C++, C\#, F\#,
Haskell, Java, OCamel. These candidates were discussed as because of
the tool \emph{BNF converter}(BNFC) supports them. Haskell was
excluded first of all, mainly because of the restricted set of
users. The developers of Copernicus needs to easily be able to modify
the implementation when necessary. The next candidate was Java, but it
was excluded because of the possible difficulties when installing java
runtime environment on supercomputers. C was a good candidate since
Copernicus is written in Python and C is easy to extend in Python, and
most systems has a C compiler as default.

The the implementation chosen was Python. As the rest of the system is
written in Python, it is only natural to write extensions in the same
language. Unix systems have Python interpreter as default, which makes
the extension easy to install aswell. The decision was also based on
easy integration and maintenance against easy implementation. As BNFC
is a powerfull tool, generating lexer, parser and abstract syntax tree
from a simple BNF description, it is the easy implementation
choice. Though this is important, easy integration and maintenance was
prioritized.


\subsection{Tools}
BNFC was the first tool considered to be used. The main reason for
this is that BNFC is a part of both \emph{Programming Languages} and
\emph{Compiler Construction} which are courses tought at
Chalmers. Experience and knowledge would have made it easy and
effective to use. The reason why another tool was chosen is stated in
the previous section.

When the implementation language was established, the tools considered
was ply, YAPPS and Spark.


\subsection{Datastructures \& Methods}
The abstract syntax tree is designed with a visitor pattern. The
elements in the visitor pattern is build like a tree where each node
has children. A node is a syntactic object where its children are
values or other syntactic objects. By defining the visit methods for
each sort of node, one perform operations based on a abstract syntax
tree simply by visiting its top node. This way it is easy to write a
typechecker and XML generator.

environment - dict (components/functions,variables)


\section{Requirements \& Specification}

