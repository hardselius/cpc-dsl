\chapter{Method}
This chapter will give a brief exaplanation on how the project was
executed, what stages .


\section{Project overview}
The project contained three main stages: research, design and
implementation. The first plan was to sequentially work through them
one by one. In practice a more parallel approach was taken, where
designing the DSL started before the research ended and then the
implementation and design stages continued through the entire project.


\section{Research}

\subsection{Programming Paradigms}
We researched programming paradigms and programming languages similar
to what we wanted to build.

\subsubsection{Dataflow Programming}
Dataflow programming is a paradigm that models programs as a directed
graph of the data flowing between operations. It focuses on how
components of the program \emph{connects} instead of, as in imperative
programming, \emph{how they happen}. \highlight{Expand on this.}

\subsubsection{Flow-based Programming}
In flow-based programming, applications are defined as networks of
``black box'' processes. Data is exchanged across predefined
connections via message passing. \highlight{Expand on this.}

\subsubsection{Reactive Programming}
Oriented around data flows and the propagation of change. THe
underlying execution model will automatically propagate changes
through the data flow. \highlight{Expand on this.}


\section{Design}
Designing the DSL was a process which continued through the entire
project. As there are no text based solution to similar problems, the
DSL had no real starting base. The initial inspiration came from the
reasearch on programming praradigms and graphical implementations
related to network based programming.

Inspiration from well known programming languages was included for the
DSL to be simple and intuitive to the common user. Both functional and
imperative languages were considered when developing the design.

The most important steps in this process was a continuing discussion
with the developers of Copernicus. It was important to have a DSL
which they were satisfied with, but also to get input on what design
choices to make. The developers perspective was important for the DSL
to reflect realistic scenarios and to get a better collective view of
the different solutions. At each meeting the developers was presented
with a draft of the latest version of the DSL.


\section{Implementation}
The implementation stage started when the first design prototype was
done. This stage was developed parallel to the design, as both parts
influenced eachother.

The first step was to write a parser for building abstract syntax
trees. The objective was to write a BNF grammar which represented our
design. The grammar contains definitions of statements, expressions,
types, etc.

A type checker was the next step to be implemented. A type checker can
provide the user with more expressive error reporting, and will also
facilitate the learning experience.

The last step was the XML generation. As this step is the one
connecting the project to Copernicus, it required a more detailed
understanding of how the system described and used computational
projects.




\subsection{Language}
The candidates for implementation language were: C, C++, C\#, F\#,
Haskell, Java, OCamel. These candidates were discussed since the
\emph{BNF converter} (BNFC) tool supports them. \citep{bnfc:online}
Haskell was excluded first of all, mainly because of the restricted
set of users. The developers of Copernicus needs to easily be able to
modify the implementation when necessary. The next candidate was Java,
but it was excluded because of the possible difficulties when
installing java runtime environment on supercomputers. C was a good
candidate since Copernicus is written in Python and C is easy to
extend in Python, and most systems has a C compiler as default.

The the implementation chosen was Python. As the rest of the system is
written in Python, it is only natural to write extensions in the same
language. UNIX systems have Python interpreter as default, which makes
the extension easy to install aswell. The decision was also based on
easy integration and maintenance against easy implementation. As BNFC
is a powerfull tool, generating lexer, parser and abstract syntax tree
from a simple BNF description, it is the easy implementation
choice. Though this is important, easy integration and maintenance was
prioritized.


\subsection{Tools}
BNFC was the first tool considered to be used. The main reason for
this is that BNFC is a part of both \emph{Programming Languages} and
\emph{Compiler Construction} which are courses tought at
Chalmers. Experience and knowledge would have made it easy and
effective to use. The reason why another tool was chosen is stated in
the previous section.

When the implementation language was established, the tools considered
was PLY, YAPPS and SPARK\citep{ply:online,yapps:online,spark:online}.

\highlight{SKRIV!!!}


\subsection{Datastructures \& Methods}
The abstract syntax tree is designed with a visitor pattern. The
elements in the visitor pattern is build like a tree where each node
has children. A node is a syntactic object where its children are
values or other syntactic objects. By defining the visit methods for
each sort of node, one perform operations based on a abstract syntax
tree simply by visiting its top node. This way it is easy to write a
typechecker and XML generator.

The type checker keeps environment information in a list of
dictionaries, where each element in the list is a scope in the
language. The dictionaries contain type information of functions and
variables. New type definitions are stored in a seperate dictionary.


\section{Requirements \& Specification}

