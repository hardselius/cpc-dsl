\documentclass[a4paper]{article}

%\usepackage[latin1]{inputenc}
\usepackage[utf8]{inputenc}

\title{Planning report\\
  \large{Domain-specific language for high-level
  sampling tasks in high-performance computing
  }
}

\author{Martin Hardselius \and Viktor Almqvist} 

\date{2 februari 2012}

\begin{document}

\maketitle
\newpage

\section{Background}

\section{Aim}

The goal of this project is to design and implement a domain-specific
language for describing data-flow networks. The DSL is to be
specifically designed for the project Copernicus, which the DSL will
describe input data for. The language should allow Copernicus plug-in
libraries and the internal network must be algorithmically
expressible, so the user can query a full state. The language should
be simple enough to describe data-flow networks as plain code, but
also designed with the possibility to easily add a graphical
interface.


\section{Problem}

Used by non-programmers
allow/include all features offerd in the data-flow networks in Copernicus



\section{Scope}

An important part for us is to get a working solution since our result
supposed to be used by the users of Copernicus. The system input is
currently in XML form, but our compiler could render using XML
redundant. As we mainly want a fully functional compiler though, we
will generate XML code. This will save time and will enable us to
focus on the more important parts of our project. If there is time, we
will look into the possibility of bypassing the XML code
generation. This is though a unnecessary objective.

We will not focus on optimizing or removing redundant code. As we se
it, the DSL will be used in such a fashion that the importance of
optimization is limited.

\section{Method}
Our method for making the compiler is devided into five steps; study
input data, language syntax, parser, type checker and code
generation. The code generation part includes the additional optional
part describe in the scope section above. The last three parts are
simply the standard three parts of a compiler, while the first two are
part of designing the language to suit the users.

We have not included an optimization step in the compiler due to the
nature of the language. It is a language to describe dataflow
networks, but not to execute any code segments. We may include some
sort of optimization when we understand more of the project.

We have chosen to write the compiler in Java instead of in Haskell,
which we are more knowledgeable in. There are two reasons for this
decision. The first is to ensure that more people can take over and
understand our code when we leave the project, since Java is a more
commonly known language than Haskell. The second reason is that we
want to learn and become more adept Java coders before we graduate
from Chalmers.


\subsection{Research}
Our first objective is to fully understand the structure of the input
data. We will studying project code, the XML code examples used for
testing the system and discuss the design choices with the
developers. We need to understand how the input data hierarchy works,
functions and subnets are defined, etc. Understanding these structures
are necessary to continue to the next part of the method.

\subsection{Design}
After and probably during the study period, we will start defining a
language syntax. We expect to make a simple draft to show our ideas
for a structure of the language. We do not want to define the whole
syntax by ourselves since we may miss important features which should
be included. That is why we will show the draft to the developers to
get their input and own design ideas. Working from this point with a
continuous input from the developers will result in us creating a good
syntax that they are satisfied with and we, as language creators,
think is a clean syntax and know will be a simple and effective to
implement.

\subsection{Implementation}
\subsubsection{Parser}
We can start implementing the compiler when the language syntax has
been established. The first step is to write a parser for building
abstract syntax trees. We will use BNFC which is a tool for generating
a finished parser from BNF grammar. Our objective is to write a BNF
grammar which represent our syntax defined in the previous step. The
grammar will contain the defenition of statements, expressions, types,
etc.

\subsubsection{Type Checker}
Some sort of type checking will be implemented to make our
contribution a more powerfull tool for the users. It is hard to know
at this point what kind of incorrect code is possible for a type
checker to do to find, since we do not know anything about the
language.

\subsubsection{Code Generation}
Once we have a type checker we can start with the final part of the
compiler, the code generator. The code generator will generate XML
code which can be used directly as input for the current system
without any complications.

The optional additional part is to skip the XML code generation and
generate Python code directly. As we understand it, the system does
currently convert the XML code to Python code which makes this part
not necessary but a better solution. If we would add this part we
would have to re-write some of the current system to take Python code
as input instead. By doing this step we would eliminate the redundant
step of generating XML code, but it will also take more time.


\section{Time Plan}

\end{document}
