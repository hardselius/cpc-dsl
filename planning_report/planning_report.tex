\documentclass[a4paper]{article}

\usepackage[utf8]{inputenc}

\usepackage{tikz}
\usepackage{gantt}

\title{Planning report\\
  \large{Domain-specific language for high-level
  sampling tasks in high-performance computing
  }
}

\author{Martin Hardselius \and Viktor Almqvist} 

\date{2 februari 2012}

\begin{document}

\maketitle
\newpage

\section{Background}

\section{Aim}

The goal of this project is to design and implement a domain-specific
language for describing data-flow networks. The DSL is to be
specifically designed for the project Copernicus, which the DSL will
describe input data for. The language should allow Copernicus plug-in
libraries and the internal network must be algorithmically
expressible, so the user can query a full state. The language should
be simple enough to describe data-flow networks as plain code, but
also designed with the possibility to easily add a graphical
interface.


\section{Problem}

Used by non-programmers allow/include all features offered in the
data-flow networks in Copernicus



\section{Scope}

An important part for us is to get a working solution since our result
supposed to be used by the users of Copernicus. The system input is
currently in XML form, but our compiler could render using XML
redundant. As we mainly want a fully functional compiler though, we
will generate XML code. This will save time and will enable us to
focus on the more important parts of our project. If there is time, we
will look into the possibility of bypassing the XML code
generation. This is though a unnecessary objective.

We will not focus on optimizing or removing redundant code. As we se
it, the DSL will be used in such a fashion that the importance of
optimization is limited.

\section{Method}
Our method for making the DSL is devided into three steps; research,
design, implementaion. We will have short daily meetings with our
supervisors during the first period of the research step. We will
discuss what we have done since the last meeting and what we will be
doing until the next one. We will meet less often later on, since the
first part is to make sure we get started and on the right track..

\subsection{Research}
Our first objective is to reasearch DSL concerning data-flow
networks. We want to find inspiration to our own DSL, and understand
more what usefull features we can add as generally are included. We
will learn what will be unique with our DSL.

Next we need to fully understand the structure of the input data. We
will studying project code, the XML code examples used for testing the
system and discuss the design choices with the developers. We need to
understand how the input data hierarchy works, functions and subnets
are defined, etc. Understanding these structures are necessary to
continue to the next part of the method.

\subsection{Design}
After and probably during the research period, we will start defining
a language syntax. We expect to make a simple draft to show our ideas
for a structure of the language. We do not want to define the whole
syntax by ourselves since we may miss important features which should
be included. That is why we will show the draft to the developers to
get their input and own design ideas. Working from this point with a
continuous input from the developers will result in us creating a good
syntax that both the developers and we are satisfied with.  The syntax
need to be clean and be clear and effective to implement.

\subsection{Implementation}
\subsubsection{Parser}
We can start implementing the compiler when the language syntax has
been established. The first step is to write a parser for building
abstract syntax trees. We will use BNFC which is a tool for generating
a finished parser from BNF grammar. Our objective is to write a BNF
grammar which represent our syntax defined in the previous step. The
grammar will contain defenitions of statements, expressions, types,
etc. We chose to use BNFC because we have experience using it and we
have yet to decide which language we want to use when implementing the
compilar. BNFC has support for the following languages: C, C++, C\#,
F\#, Haskell, Java, OCamel.

We have chosen not to write the compiler in Haskell, which we have the
most experience in using. There are two reasons for this decision. The
first is to ensure that anyone can more easily take over and
understand our code (or write a graphical interface) when we leave the
project, since Java, C, C++, C# are more commonly known languages. The
second reason is that we want to learn and become more adept coders in
other languages than Haskell before we graduate from Chalmers.

\subsubsection{Type Checker}
Type checking will be implemented to make our contribution a more
powerfull tool for the users. It is hard to know at this point what
kind of incorrect code is possible for a type checker to do to find,
since we do not know anything about the language. We will have in mind
the possibilities for a type checker during the research phase.

By now we will have chosen an implementation language, since the type
checker is the first part written in that language.

\subsubsection{Code Generation}
Once we have a type checker we can start with the final part of the
compiler, the code generator. The code generator will generate XML
code which can be used directly as input for Copernicus without any
complications. It is crucial during this part for us to fully
understand the structure of the XML code describing data-flow
networks.

The optional additional part is to skip the XML code generation and
generate Python code directly. As we understand it, the system does
currently convert the XML code to Python code which makes this part
not necessary but a better solution. If we would add this part we
would have to re-write some of the current system to take Python code
as input instead. By doing this step we would eliminate the redundant
step of generating XML code, but it will also take more time.


\section{Time Plan}
\begin{gantt}[
    xunitlength=0.5cm,
    fontsize=\small,
    titlefontsize=\small,
    drawledgerline=true]
  {8}{18}
  \begin{ganttitle}
    \titleelement{weeks}{18}
  \end{ganttitle}
  \begin{ganttitle}
    \numtitle{7}{1}{24}{1}
  \end{ganttitle}
  \ganttbar{research}{0}{4}
  \ganttbar{design}{2}{4}
  \ganttbar[pattern=crosshatch,color=red]{easter}{7}{1}
  \ganttbar{implementation}{5}{8}
  \ganttbar{report}{11}{5}
  \ganttbar{presentation}{16}{2}
\end{gantt}

\end{document}
