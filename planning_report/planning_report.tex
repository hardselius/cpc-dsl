\documentclass[a4paper]{article}
\usepackage[utf8]{inputenc}

\usepackage{tikz}
\usepackage{gantt}

\title{Planning report\\
  \large{Domain-specific language for high-level
  sampling tasks in high-performance computing
  }
}

\author{Martin Hardselius \and Viktor Almqvist} 

\date{2 februari 2012}

\begin{document}

\maketitle
\newpage

\section{Background}

\section{Aim}
The goal of this project is the creation of a domain-specific language
for describing input to the project Copernicus. Since the input to
Copernicus can be descibed as data-flow network, the design of this
DSL should adhere that paradigm. Furthermore, the language should
allow Copernicus plug-in libraries, and the internal network must be
algorithmically expressible, to allow the user to query a full
state. The language should be simple enough to describe data-flow
networks as plain code, but also designed with the possibility to
easily add a graphical interface.

\section{Problem}

The objective is to implement a domain specific language as described
in the previous section. The intended users of the language are not
necessary programmers, which makes it important for the language to be
simple and intuitive.

The DSL should be fully functional which mean it must include all
features and structures offered in the data-flow networks in
Copernicus. It should be possible to pipe the compiler to Copernicus,
which means the output form the compiler should be in the same form as
the input for Copernicus.


\section{Scope}
The most important part is to get a working solution since the DSL is
supposed to be used by the users of Copernicus. The input to the
system is curently described in XML, but the DSL and its compiler
could render the use of XML redundant. As the main objective is a
fully functional compiler, we will generate XML code. This saves time
and will enable us to focus on the more important parts of our
project. If there is time when we are done with the translation from
our language to XML, we will look into the possibility of an extention
that bypasses the XML-code generation.

\section{Method}
Our method for making the DSL is devided into three steps: research,
design, implementaion. We will have short daily meetings with our
supervisors during the first period of the research step, where we
will discuss what has been done since the last meeting and what we
will be doing until the next one. We will meet less often later on,
since the first part is to make sure we get started and on the right
track.

\subsection{Research}
Our first objective is to reasearch languages describing data-flow
networks to get a good sense on how such languages are designed. This
will serve as an inspiration to our DSL design.

The next objective is to learn the structure of the current input
data. We will be studying project code, the XML-code examples used for
testing the system and discuss the DSL design with the Copernicus
developers. We need to understand how the input data hierarchy works,
how functions and subnets are defined, etc.

\subsection{Design}
After and, probably during, the research period, we will start to
define a language syntax. We expect to make a simple draft to show our
ideas for a structure of the language. During syntax development, we
will discuss our draft regularly with the Copernicus devlopers to
avoid missing any important features.

Working from this point with a continuous input from the developers
will result in us creating a good syntax that both the developers and
we are satisfied with. The syntax need to be clean and be clear and
effective to implement.

\subsection{Implementation}
\subsubsection{Parser}
We can start implementing the compiler when the language syntax has
been established. The first step is to write a parser for building
abstract syntax trees. We will use BNFC which is a tool for generating
a finished parser from BNF grammar. Our objective is to write a BNF
grammar which represent our syntax defined in the previous step. The
grammar will contain defenitions of statements, expressions, types,
etc. We chose to use BNFC because we have experience using it and we
have yet to decide which language we want to use when implementing the
compilar. BNFC has support for the following languages: C, C++, C\#,
F\#, Haskell, Java, OCamel.

We have chosen not to write the compiler in Haskell, which we have the
most experience in using. There are two reasons for this decision. The
first is to ensure that anyone can more easily take over and
understand our code (or write a graphical interface) when we leave the
project, since Java, C, C++, C\# are more commonly known languages. The
second reason is that we want to learn and become more adept coders in
other languages than Haskell before we graduate from Chalmers.

\subsubsection{Type Checker}
Type checking will be implemented to make our contribution a more
powerfull tool for the users. It is hard to know at this point what
kind of incorrect code is possible for a type checker to do to find,
since we do not know anything about the language. We will have in mind
the possibilities for a type checker during the research phase.

By now we will have chosen an implementation language, since the type
checker is the first part written in that language.

\subsubsection{Code Generation}
Once we have a type checker we can start with the final part of the
compiler, the code generator. The code generator will generate XML
code which can be used directly as input for Copernicus. It is crucial
during this part to fully understand the structure of the XML code
describing data-flow networks. At this point we can start trying out
our project with Copernicus as we add parts of the code generator.


\section{Time Plan}
\begin{gantt}[
    xunitlength=0.5cm,
    fontsize=\small,
    titlefontsize=\small,
    drawledgerline=true]
  {8}{18}
  \begin{ganttitle}
    \titleelement{weeks}{18}
  \end{ganttitle}
  \begin{ganttitle}
    \numtitle{7}{1}{24}{1}
  \end{ganttitle}
  \ganttbar{research}{0}{4}
  \ganttbar{design}{2}{4}
  \ganttbar[pattern=crosshatch,color=red]{easter}{7}{1}
  \ganttbar{implementation}{5}{8}
  \ganttbar{report}{11}{5}
  \ganttbar{presentation}{16}{2}
\end{gantt}

\end{document}
